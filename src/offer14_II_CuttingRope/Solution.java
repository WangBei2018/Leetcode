package offer14_II_CuttingRope;

/**
 * @Author WangBei
 * @Date 2021/6/29 21:55
 * @Description: 题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1]
 * 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 * <p>
 * 示例 1：
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1
 * <p>
 * 示例2:
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 ×3 ×4 = 36
 * <p>
 * 提示：
 * 2 <= n <= 1000
 */
public class Solution {
    public int cuttingRope(int n) {
        if (n < 2) return 0;
        if (n == 2) return 1;
        if (n == 3) return 2;

        // 这里的mul不能写成int类型，因为当mul是int类型，当前的乘积小于1000000007时不会超出int的范围，
        // 但是当前数字*3之后的数字可能越界，但是当前数字*3后的数字永远不会超过long类型的范围，
        // 因为每次都会对1000000007取余，所以循环中成绩最大值是1000000006*3。
        long mul = 1L;
        // 尽可能的将n分为长度为3的绳子段。当最后剩余的绳子长度为4时，应分为2*2，而不是1*3，因为2*2>1*3，
        // 所以while循环的终止条件是n==4时，此时n可能的取值是4，3，2，最终的乘积就是mil*n。
        while (n > 4) {
            mul = (mul * 3) % 1000000007;           // 循环取余
            n -= 3;
        }
        return (int) ((mul * n) % 1000000007);
    }
}
